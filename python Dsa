1.bitwise or of subarays
class Solution:
 def subarrayBitwiseORs(self, arr: List[int]) -> int:
arr=[1,2]
result=set()
curr={0}
for i in arr:
    curr={i} | { i | j for j in curr}
    result|=curr
print(len(result))



2.find peek element
o(n) time complexity approach
nums=[1,2]
a=0
for i in range(1,len(nums)):
    if(nums[i]<nums[i-1]):
        a=i-1
a=1  
print(a)
o(logn) time complexity approach

nums=[1,2,3,1]
l=0
r=len(nums)-1
        
while l<r:
    mid=(l+r)//2
    if nums[mid]>nums[mid+1]:
        r=mid
    elif nums[mid]<nums[mid+1]:
        l=mid+1       
print(l)




3. Matrix Diagonal Sum(1572)
mat = [[1,1,1,1],
       [1,1,1,1],
       [1,1,1,1],
       [1,1,1,1]]
j=len(mat)-1
sum=0
for i in range(len(mat)):
   
    if [i,i]==[i,j]:
        sum+=mat[i][i]
        j=j-1
        
    else:
        sum+=mat[i][i]+mat[i][j]
        j=j-1
    print(sum)
    
    
    
    4.longest substring without repeatation(3) 
sett=set()

s="afbfacdeejkoi"
maxm=0
j=0
for i in range(len(s)):
    while (s[i] in sett):
        sett.remove(s[j])
        j=j+1
    print(sett)
    sett.add(s[i])
    maxm=max(i-j+1,maxm)
    print(maxm)


5. Minimum Operations to Make the Array Increasing(1827.)
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        sum=0
        for i in range(len(nums)-1):
            if nums[i]>=nums[i+1]:
                sum+=nums[i]-nums[i+1]+1
                nums[i+1]+=nums[i]-nums[i+1]+1
        return sum
        
 6.permutation of string "abc"
b=[]
def permute(init,fin):
    if(len(init)==0):
        b.append(fin)
    

    for i in range(len(init)):
        newfin=str(fin)
        newfin=newfin+init[i]
        newinit=str(init[0:i]+init[i+1:len(init)])
        permute(newinit,newfin)
    return

permute("abc","")
print(b)

            
7. Sum of All Subset XOR Totals(1863.)
class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        n=len(nums)
        result=0
        for i in range(1<<n):
            total=0
            for j in range(n):
                if((i & 1<<j)>0):
                    total^=nums[j]
            result+=total
        return result
   
8.finding subsets of [1,2,3]
a=[1,2,3]    
n=len(a)

result=[]

for i in range(1<<n):
   
    arr=[]
    for j in range(n):
        if ((i & 1<<j)!=0):
            arr.append(a[j])
    result.append(arr)
print(result)


9. Find N Unique Integers Sum up to Zero(1304)

class Solution:
    def sumZero(self, n: int) -> List[int]:
        if n==1:
            return [0]
        a=[0]*n
        if(n%2!=0):
            for i in range(n):
                a[i]=n//2+i-n+1
        else:
             for i in range(n//2):
                a[i]=i-n//2
                a[len(a)-1-i]= n//2-i
        return a

